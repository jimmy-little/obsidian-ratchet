/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RatchetPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/utils/DateUtils.ts
function startOfDayLocal(d) {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}
function startOfWeekLocal(d, firstDayOfWeek) {
  const day = d.getDay();
  const diff = (day - firstDayOfWeek + 7) % 7;
  const start = new Date(d);
  start.setDate(d.getDate() - diff);
  return startOfDayLocal(start);
}
function startOfMonthLocal(d) {
  return new Date(d.getFullYear(), d.getMonth(), 1);
}
function startOfYearLocal(d) {
  return new Date(d.getFullYear(), 0, 1);
}
function getPeriodStart(period, now, firstDayOfWeek) {
  switch (period) {
    case "never":
      return new Date(0);
    case "daily":
      return startOfDayLocal(now);
    case "weekly":
      return startOfWeekLocal(now, firstDayOfWeek);
    case "monthly":
      return startOfMonthLocal(now);
    case "yearly":
      return startOfYearLocal(now);
    default:
      return startOfDayLocal(now);
  }
}
function isInPeriod(eventTimestamp, period, now, firstDayOfWeek) {
  if (period === "never")
    return true;
  const eventDate = new Date(eventTimestamp);
  const periodStart = getPeriodStart(period, now, firstDayOfWeek);
  return eventDate.getTime() >= periodStart.getTime();
}
function getMonthKey(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  return `${y}-${m}`;
}

// src/data/EventLog.ts
function parseEventLine(line) {
  const trimmed = line.trim();
  if (!trimmed)
    return null;
  try {
    const o = JSON.parse(trimmed);
    if (o && typeof o === "object" && typeof o.tracker === "string" && typeof o.value === "number") {
      const e = o;
      return {
        id: typeof e.id === "string" ? e.id : "",
        timestamp: typeof e.timestamp === "string" ? e.timestamp : "",
        tracker: e.tracker,
        value: e.value,
        note: typeof e.note === "string" ? e.note : ""
      };
    }
  } catch (e) {
  }
  return null;
}
function eventToLine(e) {
  return JSON.stringify(e) + "\n";
}

// src/data/DataManager.ts
var CONFIG_FILE = "config.json";
var EVENTS_DIR = "events";
var CONFIG_VERSION = "1.0.0";
var DataManager = class {
  constructor(vault, dataFolder, firstDayOfWeek) {
    this.vault = vault;
    this.dataFolder = dataFolder;
    this.firstDayOfWeek = firstDayOfWeek;
  }
  configPath() {
    return `${this.dataFolder}/${CONFIG_FILE}`;
  }
  eventsDir() {
    return `${this.dataFolder}/${EVENTS_DIR}`;
  }
  eventFilePath(monthKey) {
    return `${this.eventsDir()}/${monthKey}.jsonl`;
  }
  async ensureDataFolder() {
    const dir = this.eventsDir();
    if (!await this.vault.adapter.exists(dir)) {
      await this.vault.adapter.mkdir(dir);
    }
  }
  async readConfig() {
    const path = this.configPath();
    try {
      const raw = await this.vault.adapter.read(path);
      const data = JSON.parse(raw);
      if (data && data.trackers && typeof data.trackers === "object") {
        return data;
      }
    } catch (e) {
    }
    return { version: CONFIG_VERSION, trackers: {} };
  }
  async writeConfig(config) {
    await this.ensureDataFolder();
    await this.vault.adapter.write(this.configPath(), JSON.stringify(config, null, "	"));
  }
  normalizeTracker(t) {
    var _a;
    return {
      ...t,
      goalType: (_a = t.goalType) != null ? _a : "at least"
    };
  }
  async getAllTrackers() {
    const config = await this.readConfig();
    return Object.values(config.trackers).map((t) => this.normalizeTracker(t));
  }
  async getTracker(id) {
    var _a;
    const config = await this.readConfig();
    const t = (_a = config.trackers[id]) != null ? _a : null;
    return t ? this.normalizeTracker(t) : null;
  }
  async createTracker(config) {
    const data = await this.readConfig();
    data.trackers[config.id] = config;
    await this.writeConfig(data);
  }
  async updateTracker(id, updates) {
    const data = await this.readConfig();
    const existing = data.trackers[id];
    if (!existing)
      return;
    data.trackers[id] = { ...existing, ...updates };
    await this.writeConfig(data);
  }
  async deleteTracker(id) {
    const data = await this.readConfig();
    delete data.trackers[id];
    await this.writeConfig(data);
  }
  /** Month keys to read for current period (e.g. this month + last for weekly). */
  monthKeysToRead(period, now) {
    const keys = [];
    const current = getMonthKey(now);
    keys.push(current);
    if (period === "weekly" || period === "daily") {
      const prev = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      keys.push(getMonthKey(prev));
    }
    if (period === "yearly") {
      const y = now.getFullYear();
      for (let m = 0; m < 12; m++)
        keys.push(`${y}-${String(m + 1).padStart(2, "0")}`);
    }
    return [...new Set(keys)];
  }
  async readEventsForTracker(trackerId, monthKeys) {
    const events = [];
    for (const key of monthKeys) {
      const path = this.eventFilePath(key);
      try {
        const content = await this.vault.adapter.read(path);
        for (const line of content.split("\n")) {
          const e = parseEventLine(line);
          if (e && e.tracker === trackerId)
            events.push(e);
        }
      } catch (e) {
      }
    }
    events.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
    return events;
  }
  async getCurrentCount(trackerId, trackerPeriod) {
    var _a;
    const tracker = await this.getTracker(trackerId);
    const period = (_a = trackerPeriod != null ? trackerPeriod : tracker == null ? void 0 : tracker.resetPeriod) != null ? _a : "daily";
    const now = new Date();
    const keys = this.monthKeysToRead(period, now);
    const events = await this.readEventsForTracker(trackerId, keys);
    let sum = 0;
    for (const e of events) {
      if (isInPeriod(e.timestamp, period, now, this.firstDayOfWeek)) {
        sum += e.value;
      }
    }
    return sum;
  }
  /**
   * For "at least" goals: true if the running sum ever reached >= goal this period
   * (so toggling +1 then -1 back to 0 still shows as "goal met").
   * For "at most": true if current count <= goal (no running-sum check needed).
   */
  async getGoalWasEverMetThisPeriod(trackerId) {
    const tracker = await this.getTracker(trackerId);
    if (!tracker || tracker.goalType === "none")
      return false;
    const now = new Date();
    const period = tracker.resetPeriod;
    const keys = this.monthKeysToRead(period, now);
    const events = await this.readEventsForTracker(trackerId, keys);
    const inPeriod = events.filter(
      (e) => isInPeriod(e.timestamp, period, now, this.firstDayOfWeek)
    );
    if (tracker.goalType === "at most") {
      const sum2 = inPeriod.reduce((s, e) => s + e.value, 0);
      return sum2 <= tracker.goal;
    }
    let sum = 0;
    for (const e of inPeriod) {
      sum += e.value;
      if (tracker.goal > 0 && sum >= tracker.goal)
        return true;
    }
    return false;
  }
  /** Sum of event values for a single calendar day (local date). */
  async getCountForDay(trackerId, date) {
    const start = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const end = new Date(start);
    end.setDate(end.getDate() + 1);
    const events = await this.getHistory(trackerId, start, new Date(end.getTime() - 1));
    return events.reduce((sum, e) => sum + e.value, 0);
  }
  /** Whether the goal was met on that calendar day (for heatmap). */
  async getGoalMetForDay(trackerId, date) {
    const status = await this.getGoalStatusForDay(trackerId, date);
    return status === "met";
  }
  /**
   * Goal status for a single day (for heatmap). Returns "no_data" when there are no events
   * that day, so historical days without logging show as grey instead of met.
   */
  async getGoalStatusForDay(trackerId, date) {
    const tracker = await this.getTracker(trackerId);
    if (!tracker || tracker.goalType === "none")
      return "no_data";
    const start = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const end = new Date(start);
    end.setDate(end.getDate() + 1);
    const events = await this.getHistory(trackerId, start, new Date(end.getTime() - 1));
    if (events.length === 0)
      return "no_data";
    const count = events.reduce((sum, e) => sum + e.value, 0);
    const met = tracker.goalType === "at least" ? tracker.goal <= 0 || count >= tracker.goal : count <= tracker.goal;
    return met ? "met" : "not_met";
  }
  /** Day key YYYY-MM-DD in local time */
  static dateKey(d) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }
  /**
   * Entries per day in range (for edit-history grid). One read for the whole range.
   * Sorted by date descending (most recent first).
   */
  async getDayEntries(trackerId, startDate, endDate) {
    var _a, _b, _c, _d;
    const events = await this.getHistory(trackerId, startDate, endDate);
    const byDay = /* @__PURE__ */ new Map();
    for (const e of events) {
      const d = new Date(e.timestamp);
      const key = DataManager.dateKey(d);
      const cur = (_a = byDay.get(key)) != null ? _a : {
        count: 0,
        eventCount: 0,
        hasDoneMarker: false
      };
      cur.count += e.value;
      cur.eventCount += 1;
      if (e.value === 0)
        cur.hasDoneMarker = true;
      byDay.set(key, cur);
    }
    const start = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
    const end = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
    const out = [];
    for (const d = new Date(end); d.getTime() >= start.getTime(); d.setDate(d.getDate() - 1)) {
      const key = DataManager.dateKey(d);
      const row = byDay.get(key);
      out.push({
        dateKey: key,
        date: new Date(d),
        count: (_b = row == null ? void 0 : row.count) != null ? _b : 0,
        eventCount: (_c = row == null ? void 0 : row.eventCount) != null ? _c : 0,
        hasDoneMarker: (_d = row == null ? void 0 : row.hasDoneMarker) != null ? _d : false
      });
    }
    return out;
  }
  async getHistory(trackerId, startDate, endDate) {
    const startKey = getMonthKey(startDate);
    const endKey = getMonthKey(endDate);
    const keys = [];
    const [sy, sm] = startKey.split("-").map(Number);
    const [ey, em] = endKey.split("-").map(Number);
    for (let y = sy; y <= ey; y++) {
      const mStart = y === sy ? sm : 1;
      const mEnd = y === ey ? em : 12;
      for (let m = mStart; m <= mEnd; m++) {
        keys.push(`${y}-${String(m).padStart(2, "0")}`);
      }
    }
    const events = await this.readEventsForTracker(trackerId, keys);
    const startMs = startDate.getTime();
    const endMs = endDate.getTime();
    return events.filter((e) => {
      const t = new Date(e.timestamp).getTime();
      return t >= startMs && t <= endMs;
    });
  }
  async increment(trackerId, value, note = "") {
    await this.incrementOnDate(trackerId, value, new Date(), note);
  }
  /** Add an event for a specific calendar day (e.g. from heatmap click). Uses noon local so it unambiguously belongs to that day. */
  async incrementOnDate(trackerId, value, date, note = "") {
    await this.ensureDataFolder();
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    const atNoon = new Date(year, month, day, 12, 0, 0, 0);
    const monthKey = getMonthKey(atNoon);
    const path = this.eventFilePath(monthKey);
    const event = {
      id: typeof crypto !== "undefined" && crypto.randomUUID ? crypto.randomUUID() : `e-${Date.now()}-${Math.random().toString(36).slice(2)}`,
      timestamp: atNoon.toISOString(),
      tracker: trackerId,
      value,
      note
    };
    const line = eventToLine(event);
    try {
      const existing = await this.vault.adapter.read(path).catch(() => "");
      await this.vault.adapter.write(path, existing + line);
    } catch (e) {
      await this.vault.adapter.write(path, line);
    }
  }
};

// src/settings/Settings.ts
var DEFAULT_SETTINGS = {
  dataFolder: ".ratchet",
  firstDayOfWeek: 0,
  defaultIncrementButtons: [1]
};

// src/settings/SettingsTab.ts
var import_obsidian = require("obsidian");
var RatchetSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Ratchet" });
    containerEl.createEl("p", {
      text: 'Open the dashboard from the ribbon (gear icon) or command palette: "Ratchet: Open Dashboard". Create trackers there, then use the settings below to change where data is stored and default behavior.',
      cls: "ratchet-settings-desc"
    });
    new import_obsidian.Setting(containerEl).setName("Data folder").setDesc("Folder in your vault for tracker config and event logs. Default: .ratchet (hidden folder at vault root)").addText(
      (text) => text.setPlaceholder(".ratchet").setValue(this.plugin.settings.dataFolder).onChange(async (value) => {
        this.plugin.settings.dataFolder = value.trim() || ".ratchet";
        await this.plugin.saveSettings();
        this.plugin.refreshDataManager();
      })
    );
    new import_obsidian.Setting(containerEl).setName("First day of week").setDesc('Used for trackers with "Weekly" reset (e.g. week starts Monday)').addDropdown(
      (d) => d.addOption("0", "Sunday").addOption("1", "Monday").setValue(String(this.plugin.settings.firstDayOfWeek)).onChange(async (value) => {
        this.plugin.settings.firstDayOfWeek = value === "1" ? 1 : 0;
        await this.plugin.saveSettings();
        this.plugin.refreshDataManager();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default increment buttons").setDesc("Comma-separated values for new trackers (e.g. 1, 5, 10). Default is 1. Each tracker can override in Edit.").addText(
      (text) => text.setPlaceholder("1").setValue(this.plugin.settings.defaultIncrementButtons.join(", ")).onChange(async (value) => {
        const parsed = value.split(",").map((s) => parseInt(s.trim(), 10)).filter((n) => !isNaN(n) && n > 0);
        this.plugin.settings.defaultIncrementButtons = parsed.length > 0 ? parsed : [1];
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/ui/RatchetMainView.ts
var import_obsidian2 = require("obsidian");

// src/data/TrackerConfig.ts
var RESET_PERIOD_LABELS = {
  never: "Never",
  daily: "Daily",
  weekly: "Weekly",
  monthly: "Monthly",
  yearly: "Yearly"
};
var DEFAULT_TRACKER_COLOR = "#7c3aed";
function makeTrackerId(name) {
  return name.toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "");
}
function createTracker(overrides) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const id = (_a = overrides.id) != null ? _a : makeTrackerId(overrides.name);
  const now = new Date().toISOString();
  return {
    id,
    name: overrides.name,
    icon: (_b = overrides.icon) != null ? _b : "\u{1F4CC}",
    resetPeriod: (_c = overrides.resetPeriod) != null ? _c : "daily",
    color: (_d = overrides.color) != null ? _d : DEFAULT_TRACKER_COLOR,
    unit: (_e = overrides.unit) != null ? _e : "",
    goal: (_f = overrides.goal) != null ? _f : 0,
    goalType: (_g = overrides.goalType) != null ? _g : "at least",
    created: (_h = overrides.created) != null ? _h : now,
    incrementButtons: ((_i = overrides.incrementButtons) == null ? void 0 : _i.length) ? overrides.incrementButtons : [1]
  };
}
function hasGoal(t) {
  return t.goalType !== "none" && (t.goalType === "at most" || t.goal > 0);
}
function isGoalMet(t, current) {
  if (t.goalType === "none")
    return false;
  if (t.goalType === "at least")
    return t.goal <= 0 || current >= t.goal;
  return current <= t.goal;
}

// src/ui/TrackerCard.ts
function renderTrackerCard(container, options) {
  container.empty();
  const { tracker, dataManager, onIncrement, onOpenDetail } = options;
  const card = container.createDiv("ratchet-card");
  card.style.setProperty("--ratchet-card-accent", tracker.color || "var(--background-modifier-border)");
  const header = card.createDiv("ratchet-card-header");
  header.createSpan({ cls: "ratchet-card-icon", text: tracker.icon });
  header.createSpan({ cls: "ratchet-card-name", text: tracker.name });
  if (onOpenDetail) {
    header.addClass("ratchet-card-header-clickable");
    header.addEventListener("click", () => onOpenDetail(tracker));
  }
  const valueEl = card.createDiv("ratchet-card-value");
  const unitSuffix = tracker.unit ? ` ${tracker.unit}` : "";
  let progressBar = null;
  let progressFill = null;
  let goalEl = null;
  const updateUI = () => {
    dataManager.getCurrentCount(tracker.id).then((count) => {
      valueEl.empty();
      valueEl.createSpan({ text: String(count) });
      if (tracker.unit)
        valueEl.createSpan({ cls: "ratchet-card-unit", text: unitSuffix });
      if (progressFill) {
        let pct;
        if (tracker.goalType === "at most") {
          if (tracker.goal === 0)
            pct = count === 0 ? 0 : 100;
          else
            pct = Math.min(100, Math.max(0, count / tracker.goal * 100));
        } else {
          const denom = Math.max(tracker.goal, 1);
          pct = Math.min(100, count / denom * 100);
        }
        progressFill.style.width = `${pct}%`;
      }
      if (goalEl && tracker.goalType !== "none") {
        goalEl.empty();
        const met = isGoalMet(tracker, count);
        const periodLabel = RESET_PERIOD_LABELS[tracker.resetPeriod];
        goalEl.createSpan({
          text: `${periodLabel}: ${count}/${tracker.goal}${met ? " \u2713" : ""}`,
          cls: met ? "ratchet-card-goal-met" : ""
        });
      }
    });
  };
  updateUI();
  const btnRow = card.createDiv("ratchet-card-buttons");
  const minusBtn = btnRow.createEl("button", { text: "-1" });
  minusBtn.addEventListener("click", async (e) => {
    e.stopPropagation();
    await dataManager.increment(tracker.id, -1);
    updateUI();
    onIncrement();
  });
  for (const v of tracker.incrementButtons) {
    const btn = btnRow.createEl("button", { text: `+${v}` });
    btn.addEventListener("click", async (e) => {
      e.stopPropagation();
      await dataManager.increment(tracker.id, v);
      updateUI();
      onIncrement();
    });
  }
  if (hasGoal(tracker)) {
    const progressWrap = card.createDiv("ratchet-card-progress-wrap");
    progressBar = progressWrap.createDiv("ratchet-card-progress");
    progressFill = progressBar.createDiv("ratchet-card-progress-fill");
    progressFill.style.backgroundColor = tracker.color || "var(--interactive-accent)";
    goalEl = card.createDiv("ratchet-card-goal");
    updateUI();
  }
}

// src/ui/RatchetMainView.ts
var VIEW_TYPE_RATCHET_MAIN = "ratchet-main-view";
var RESET_OPTIONS = [
  { value: "never", label: "Never" },
  { value: "daily", label: "Daily" },
  { value: "weekly", label: "Weekly" },
  { value: "monthly", label: "Monthly" },
  { value: "yearly", label: "Yearly" }
];
var GOAL_TYPE_OPTIONS = [
  { value: "at least", label: "At least", desc: "Reach a minimum (e.g. 3 cups, close rings)" },
  { value: "at most", label: "At most", desc: "Stay at or below a cap (e.g. 0 drinks)" },
  { value: "none", label: "No goal", desc: "Just count" }
];
var PRESET_COLORS = [
  "#7c3aed",
  "#2563eb",
  "#059669",
  "#ca8a04",
  "#dc2626",
  "#db2777",
  "#7c2d12",
  "#1e293b",
  "#64748b",
  "#0f172a"
];
var RatchetMainView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_RATCHET_MAIN;
  }
  getDisplayText() {
    return "Ratchet";
  }
  getIcon() {
    return "gear";
  }
  async onOpen() {
    this.render();
  }
  async onClose() {
  }
  render() {
    const container = this.containerEl.children[1];
    if (!container)
      return;
    container.empty();
    container.addClass("ratchet-main-view");
    const scroll = container.createDiv("ratchet-main-scroll");
    const content = scroll.createDiv("ratchet-main-content");
    content.createEl("h1", { text: "Ratchet" });
    const grid = content.createDiv("ratchet-main-grid");
    const dm = this.plugin.getDataManager();
    const selectedId = this.plugin.ratchetViewState.selectedId;
    (async () => {
      const trackers = await dm.getAllTrackers();
      for (const tracker of trackers) {
        const cardWrap = grid.createDiv("ratchet-card-wrap");
        renderTrackerCard(cardWrap, {
          tracker,
          dataManager: dm,
          onIncrement: () => this.render(),
          onOpenDetail: (t) => {
            this.plugin.ratchetViewState.selectedId = t.id;
            this.render();
          }
        });
      }
      const newWrap = grid.createDiv("ratchet-card-wrap");
      const newCard = newWrap.createDiv("ratchet-card ratchet-card-new");
      newCard.createDiv("ratchet-card-new-inner").createEl("span", { text: "+ New tracker" });
      newCard.addEventListener("click", () => {
        this.plugin.ratchetViewState.selectedId = "new";
        this.render();
      });
      if (selectedId) {
        const formSection = content.createDiv("ratchet-main-form-section");
        formSection.createEl("h2", {
          text: selectedId === "new" ? "New tracker" : "Edit tracker"
        });
        this.renderTrackerForm(formSection, selectedId);
      }
    })();
  }
  renderTrackerForm(container, selectedId) {
    const isEdit = selectedId !== "new";
    const dm = this.plugin.getDataManager();
    let name = "";
    let icon = "\u{1F4CC}";
    let color = DEFAULT_TRACKER_COLOR;
    let resetPeriod = "daily";
    let goalType = "at least";
    let goal = 0;
    let unit = "";
    const incrementButtons = [...this.plugin.settings.defaultIncrementButtons];
    const loadTracker = async () => {
      var _a, _b;
      if (!isEdit)
        return;
      const t = await dm.getTracker(selectedId);
      if (t) {
        name = t.name;
        icon = t.icon;
        color = t.color || DEFAULT_TRACKER_COLOR;
        resetPeriod = t.resetPeriod;
        goalType = (_a = t.goalType) != null ? _a : "at least";
        goal = t.goal;
        unit = (_b = t.unit) != null ? _b : "";
        incrementButtons.length = 0;
        incrementButtons.push(...t.incrementButtons);
      }
    };
    (async () => {
      await loadTracker();
      const form = container.createDiv("ratchet-main-form");
      const nameSetting = new import_obsidian2.Setting(form).setName("Name").setDesc("Display name for the tracker").addText(
        (text) => text.setPlaceholder("e.g. Coffee").setValue(name).onChange((v) => {
          name = v;
          updateIdHint(v);
        })
      );
      const idHintEl = nameSetting.controlEl.createDiv("ratchet-tracker-id-hint");
      idHintEl.createSpan({ text: "Widget id: ", cls: "ratchet-tracker-id-label" });
      const idHintValue = idHintEl.createSpan("ratchet-tracker-id-value");
      const updateIdHint = (val) => {
        idHintValue.textContent = isEdit ? selectedId : makeTrackerId(val.trim()) || "\u2014";
      };
      updateIdHint(name);
      new import_obsidian2.Setting(form).setName("Icon").setDesc("Emoji or character").addText(
        (text) => text.setPlaceholder("\u{1F4CC}").setValue(icon).onChange((v) => icon = v || "\u{1F4CC}")
      );
      const colorSetting = new import_obsidian2.Setting(form).setName("Color").setDesc("Hex (e.g. #7c3aed) or pick below");
      let colorTextRef = null;
      colorSetting.addText((text) => {
        colorTextRef = text;
        text.setPlaceholder("#7c3aed").setValue(color).onChange((v) => {
          if (/^#[0-9A-Fa-f]{3,8}$/.test(v) || v === "")
            color = v || DEFAULT_TRACKER_COLOR;
        });
      });
      const colorRow = form.createDiv("ratchet-config-color-row");
      const picker = colorRow.createEl("input", { type: "color" });
      picker.value = color.startsWith("#") && color.length >= 7 ? color : DEFAULT_TRACKER_COLOR;
      picker.addEventListener("input", () => {
        color = picker.value;
        if (colorTextRef)
          colorTextRef.setValue(color);
      });
      const presets = colorRow.createDiv("ratchet-config-color-presets");
      for (const c of PRESET_COLORS) {
        const swatch = presets.createEl("button", { type: "button", cls: "ratchet-color-swatch" });
        swatch.style.backgroundColor = c;
        swatch.setAttribute("aria-label", c);
        swatch.addEventListener("click", () => {
          color = c;
          picker.value = c;
          if (colorTextRef)
            colorTextRef.setValue(c);
        });
      }
      new import_obsidian2.Setting(form).setName("Reset period").setDesc("When the count resets").addDropdown((d) => {
        for (const opt of RESET_OPTIONS)
          d.addOption(opt.value, opt.label);
        d.setValue(resetPeriod).onChange((v) => resetPeriod = v);
      });
      new import_obsidian2.Setting(form).setName("Goal type").setDesc("At least = reach minimum; At most = stay under cap; No goal = just count").addDropdown((d) => {
        for (const opt of GOAL_TYPE_OPTIONS)
          d.addOption(opt.value, `${opt.label}: ${opt.desc}`);
        d.setValue(goalType).onChange((v) => goalType = v);
      });
      new import_obsidian2.Setting(form).setName("Goal").setDesc('Target number. For "At least" use e.g. 3 or 1 (toggle). For "At most" use e.g. 0.').addText(
        (text) => text.setPlaceholder("0").setValue(String(goal)).onChange((v) => goal = Math.max(0, parseInt(v, 10) || 0))
      );
      new import_obsidian2.Setting(form).setName("Unit (optional)").setDesc("e.g. cups, minutes, pages").addText(
        (text) => text.setPlaceholder("").setValue(unit).onChange((v) => unit = v)
      );
      new import_obsidian2.Setting(form).setName("Increment buttons").setDesc("Comma-separated values for +/\u2212 buttons (e.g. 1, 5, 10). Widget and card use these.").addText(
        (text) => text.setPlaceholder("1").setValue(incrementButtons.join(", ")).onChange((v) => {
          const parsed = v.split(",").map((s) => parseInt(s.trim(), 10)).filter((n) => !isNaN(n) && n > 0);
          incrementButtons.length = 0;
          incrementButtons.push(...parsed.length ? parsed : [1]);
        })
      );
      if (isEdit) {
        this.renderPastEntriesSection(form, selectedId, dm, goalType, goal, unit, () => this.render());
      }
      const actions = form.createDiv("ratchet-config-actions");
      new import_obsidian2.ButtonComponent(actions).setButtonText("Cancel").onClick(() => {
        this.plugin.ratchetViewState.selectedId = null;
        this.render();
      });
      if (isEdit) {
        new import_obsidian2.ButtonComponent(actions).setButtonText("Delete").setClass("ratchet-btn-delete").onClick(async () => {
          await dm.deleteTracker(selectedId);
          this.plugin.ratchetViewState.selectedId = null;
          this.render();
        });
      }
      new import_obsidian2.ButtonComponent(actions).setButtonText(isEdit ? "Save" : "Create").setClass("mod-cta").onClick(async () => {
        if (!name.trim())
          return;
        const id = isEdit ? selectedId : makeTrackerId(name.trim());
        if (isEdit) {
          await dm.updateTracker(selectedId, {
            name: name.trim(),
            icon: icon || "\u{1F4CC}",
            color: color || DEFAULT_TRACKER_COLOR,
            resetPeriod,
            goalType,
            goal,
            unit: unit.trim(),
            incrementButtons: [...incrementButtons]
          });
        } else {
          const config = createTracker({
            id,
            name: name.trim(),
            icon: icon || "\u{1F4CC}",
            resetPeriod,
            color: color || DEFAULT_TRACKER_COLOR,
            unit: unit.trim(),
            goal,
            goalType,
            incrementButtons
          });
          await dm.createTracker(config);
        }
        this.plugin.ratchetViewState.selectedId = null;
        this.render();
      });
    })();
  }
  static formatEntryDate(d) {
    const weekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    return `${weekdays[d.getDay()]}, ${months[d.getMonth()]} ${d.getDate()}`;
  }
  renderPastEntriesSection(form, trackerId, dm, goalType, goal, unit, onRefresh) {
    const section = form.createDiv("ratchet-past-entries-section");
    section.createEl("h3", { text: "Past entries" });
    let daysBack = 90;
    const tableWrap = section.createDiv("ratchet-entries-table-wrap");
    const refreshTable = async () => {
      tableWrap.empty();
      const end = new Date();
      const start = new Date(end);
      start.setDate(start.getDate() - daysBack);
      const entries = await dm.getDayEntries(trackerId, start, end);
      if (entries.length === 0) {
        tableWrap.createSpan({ text: "No entries in this range.", cls: "ratchet-entries-empty" });
        return;
      }
      const table = tableWrap.createEl("table", "ratchet-entries-table");
      const thead = table.createEl("thead").createEl("tr");
      thead.createEl("th", { text: "Date" });
      thead.createEl("th", { text: "Count" });
      const tbody = table.createEl("tbody");
      for (const entry of entries) {
        const tr = tbody.createEl("tr");
        tr.createEl("td", { cls: "ratchet-entries-date", text: RatchetMainView.formatEntryDate(entry.date) });
        const valueCell = tr.createEl("td", "ratchet-entries-value");
        const input = valueCell.createEl("input", { type: "number" });
        input.addClass("ratchet-entries-count-input");
        input.setAttribute("min", "0");
        input.value = String(entry.count);
        const applyEdit = async () => {
          const newVal = parseInt(String(input.value), 10);
          if (isNaN(newVal) || newVal < 0)
            return;
          let delta = newVal - entry.count;
          if (goalType === "at most" && goal === 0 && newVal === 0 && entry.eventCount === 0) {
            delta = 0;
            await dm.incrementOnDate(trackerId, 0, entry.date, "done");
          } else if (delta === 0) {
            return;
          } else {
            await dm.incrementOnDate(trackerId, delta, entry.date, "edit");
          }
          await refreshTable();
          onRefresh();
        };
        input.addEventListener("blur", () => applyEdit());
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            input.blur();
          }
        });
      }
    };
    const rangeSetting = new import_obsidian2.Setting(section).setName("Range").setDesc("Show and edit entries from the last N days").addDropdown((d) => {
      d.addOption("30", "Last 30 days").addOption("90", "Last 90 days").addOption("365", "Last 365 days");
      d.setValue(String(daysBack)).onChange((v) => {
        daysBack = parseInt(v, 10);
        refreshTable();
      });
    });
    rangeSetting.settingEl.addClass("ratchet-entries-range-setting");
    refreshTable();
  }
};

// src/processors/CodeBlockProcessor.ts
function parseBlockParams(source) {
  const params = {};
  for (const line of source.split("\n")) {
    const m = line.match(/^\s*([a-z-]+)\s*:\s*(.+)$/i);
    if (!m)
      continue;
    const key = m[1].trim().toLowerCase();
    const raw = m[2].trim();
    if (key === "tracker")
      params.tracker = raw;
    else if (key === "buttons") {
      try {
        const arr = JSON.parse(raw);
        if (Array.isArray(arr))
          params.buttons = arr;
      } catch (e) {
      }
    } else if (key === "show-goal")
      params["show-goal"] = /^(true|1|yes)$/i.test(raw);
    else if (key === "days") {
      const n = parseInt(raw, 10);
      if (!isNaN(n) && n > 0)
        params.days = n;
    } else if (key === "period")
      params.period = raw;
  }
  return params;
}
function resolveHeatmapDays(params) {
  if (params.days != null)
    return Math.min(366, Math.max(7, params.days));
  const p = (params.period || "").toLowerCase();
  if (p === "45" || p === "1.5 months")
    return 45;
  if (p === "90" || p === "3 months" || p === "quarter")
    return 90;
  if (p === "365" || p === "year" || p === "1y")
    return 365;
  return 90;
}
function registerRatchetCounter(plugin, callback) {
  plugin.registerMarkdownCodeBlockProcessor("ratchet-counter", callback);
}
async function renderOneCounter(container, trackerId, params, plugin) {
  var _a, _b;
  const dm = plugin.getDataManager();
  const tracker = await dm.getTracker(trackerId);
  if (!tracker) {
    container.createSpan({ text: `Tracker not found: ${trackerId}`, cls: "ratchet-counter-error" });
    return false;
  }
  const buttons = ((_a = params.buttons) == null ? void 0 : _a.length) ? params.buttons : tracker.incrementButtons;
  const showGoal = (_b = params["show-goal"]) != null ? _b : true;
  const wrap = container.createDiv("ratchet-counter-wrap");
  wrap.style.setProperty("--ratchet-card-accent", tracker.color || "var(--background-modifier-border)");
  const top = wrap.createDiv("ratchet-counter-top");
  top.createSpan({ cls: "ratchet-counter-icon", text: tracker.icon });
  top.createSpan({ cls: "ratchet-counter-name", text: tracker.name });
  const countEl = wrap.createDiv("ratchet-counter-value");
  const countNum = countEl.createSpan("ratchet-counter-num");
  if (tracker.unit)
    countEl.createSpan({ cls: "ratchet-counter-unit", text: ` ${tracker.unit}` });
  const updateCount = async () => {
    const count = await dm.getCurrentCount(trackerId);
    countNum.textContent = String(count);
  };
  await updateCount();
  const btnRow = wrap.createDiv("ratchet-counter-buttons");
  const minusBtn = btnRow.createEl("button", { text: "-1" });
  minusBtn.addEventListener("click", async () => {
    await dm.increment(trackerId, -1);
    await updateCount();
  });
  for (const v of buttons) {
    const btn = btnRow.createEl("button", { text: `+${v}` });
    btn.addEventListener("click", async () => {
      await dm.increment(trackerId, v);
      await updateCount();
    });
  }
  if (showGoal && tracker.goalType !== "none") {
    const goalLine = wrap.createDiv("ratchet-counter-goal");
    const count = await dm.getCurrentCount(trackerId);
    const met = tracker.goalType === "at least" ? count >= tracker.goal : count <= tracker.goal;
    const periodLabel = RESET_PERIOD_LABELS[tracker.resetPeriod];
    goalLine.createSpan({
      text: `${periodLabel}: ${count}/${tracker.goal} ${met ? "\u2713" : ""}`,
      cls: met ? "ratchet-counter-goal-met" : ""
    });
  }
  return true;
}
async function renderRatchetCounter(source, el, plugin) {
  var _a, _b;
  const params = parseBlockParams(source);
  const raw = (_b = (_a = params.tracker) == null ? void 0 : _a.trim()) != null ? _b : "";
  if (!raw) {
    el.createSpan({ text: "ratchet-counter: specify tracker: <id> or tracker: id1, id2, id3" });
    return;
  }
  const trackerIds = raw.split(",").map((s) => s.trim()).filter(Boolean);
  if (trackerIds.length === 0) {
    el.createSpan({ text: "ratchet-counter: specify at least one tracker id" });
    return;
  }
  const container = trackerIds.length > 1 ? el.createDiv("ratchet-counters") : el;
  for (const id of trackerIds) {
    if (trackerIds.length > 1) {
      await renderOneCounter(container, id, params, plugin);
    } else {
      await renderOneCounter(el, id, params, plugin);
      break;
    }
  }
}
function registerRatchetHeatmap(plugin, callback) {
  plugin.registerMarkdownCodeBlockProcessor("ratchet-heatmap", callback);
}
var DAY_NAMES = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function addDays(d, n) {
  const out = new Date(d);
  out.setDate(out.getDate() + n);
  return out;
}
function dateKey(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
}
function isSameDay(a, b) {
  return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
}
function formatCellTitle(d) {
  const day = DAY_NAMES[d.getDay()];
  const month = MONTH_NAMES[d.getMonth()];
  const date = d.getDate();
  const year = d.getFullYear();
  return `${day}, ${month} ${date}, ${year}`;
}
function parseDateKey(key) {
  const [y, m, d] = key.split("-").map(Number);
  if (isNaN(y) || isNaN(m) || isNaN(d))
    return null;
  return new Date(y, m - 1, d, 12, 0, 0, 0);
}
async function buildHeatmapInto(container, trackerId, days, plugin, opts) {
  var _a;
  const dm = plugin.getDataManager();
  const firstDayOfWeek = plugin.settings.firstDayOfWeek;
  const tracker = await dm.getTracker(trackerId);
  if (!tracker)
    return;
  const doRerender = (_a = opts == null ? void 0 : opts.rerender) != null ? _a : (opts == null ? void 0 : opts.source) && (opts == null ? void 0 : opts.blockEl) ? () => {
    opts.blockEl.empty();
    return renderRatchetHeatmap(opts.source, opts.blockEl, plugin);
  } : void 0;
  container.__ratchetHeatmap = {
    plugin,
    trackerId,
    rerender: doRerender
  };
  const today = startOfDayLocal(new Date());
  const startDay = addDays(today, -(days - 1));
  const weekStart = startOfWeekLocal(startDay, firstDayOfWeek);
  const weekStarts = [];
  for (let d = new Date(weekStart); d.getTime() <= today.getTime() + 7 * 24 * 60 * 60 * 1e3; d = addDays(d, 7)) {
    weekStarts.push(new Date(d));
  }
  const numCols = weekStarts.length;
  container.style.setProperty("--heatmap-cols", String(numCols));
  if (!(opts == null ? void 0 : opts.hideTitle))
    container.createEl("div", { cls: "ratchet-heatmap-title", text: tracker.name });
  const body = container.createDiv("ratchet-heatmap-body");
  const monthRow = body.createDiv("ratchet-heatmap-months");
  let lastMonth = -1;
  for (let c = 0; c < weekStarts.length; c++) {
    const weekDate = weekStarts[c];
    const m = weekDate.getMonth();
    const span = monthRow.createSpan("ratchet-heatmap-month");
    if (m !== lastMonth) {
      span.textContent = MONTH_NAMES[m];
      lastMonth = m;
    }
  }
  const dayLabels = body.createDiv("ratchet-heatmap-day-labels");
  for (let row = 0; row < 7; row++) {
    const dow = (firstDayOfWeek + row) % 7;
    dayLabels.createDiv("ratchet-heatmap-day-label").setText(DAY_NAMES[dow]);
  }
  const grid = body.createDiv("ratchet-heatmap-grid");
  const goalByDate = /* @__PURE__ */ new Map();
  for (let d = new Date(startDay); d.getTime() <= today.getTime(); d = addDays(d, 1)) {
    goalByDate.set(dateKey(d), await dm.getGoalStatusForDay(trackerId, d));
  }
  const trackerColor = tracker.color || "#7c3aed";
  const notMetColor = "#dc2626";
  const noDataColor = "#ebedf0";
  for (let row = 0; row < 7; row++) {
    const rowEl = grid.createDiv("ratchet-heatmap-row");
    for (let col = 0; col < weekStarts.length; col++) {
      const cellDate = addDays(weekStarts[col], row);
      const before = cellDate.getTime() < startDay.getTime();
      const after = cellDate.getTime() > today.getTime();
      const inRange = !before && !after;
      const status = goalByDate.get(dateKey(cellDate));
      const isToday = isSameDay(cellDate, today);
      const cell = rowEl.createDiv("ratchet-heatmap-cell");
      if (!inRange) {
        cell.addClass("ratchet-heatmap-cell-empty");
        cell.style.backgroundColor = noDataColor;
      } else if (status === "met") {
        cell.addClass("ratchet-heatmap-cell-met");
        cell.style.backgroundColor = trackerColor;
      } else if (status === "not_met") {
        cell.addClass("ratchet-heatmap-cell-not-met");
        cell.style.backgroundColor = notMetColor;
      } else {
        cell.addClass("ratchet-heatmap-cell-no-data");
        cell.style.backgroundColor = noDataColor;
      }
      if (isToday)
        cell.addClass("ratchet-heatmap-cell-today");
      cell.setAttribute("data-date", dateKey(cellDate));
      cell.setAttribute("title", formatCellTitle(cellDate));
      if (inRange) {
        cell.addClass("ratchet-heatmap-cell-clickable");
        cell.addEventListener("click", async () => {
          const heatmapEl = cell.closest(".ratchet-heatmap");
          const meta = heatmapEl == null ? void 0 : heatmapEl.__ratchetHeatmap;
          if (!meta)
            return;
          const { plugin: plug, trackerId: tid, rerender } = meta;
          const dateKeyVal = cell.getAttribute("data-date");
          if (!dateKeyVal)
            return;
          const targetDate = parseDateKey(dateKeyVal);
          if (!targetDate)
            return;
          const dmm = plug.getDataManager();
          const tr = await dmm.getTracker(tid);
          if (!tr)
            return;
          const value = tr.goalType === "at most" && tr.goal === 0 ? 0 : 1;
          await dmm.incrementOnDate(tid, value, targetDate, value === 0 ? "done" : "");
          if (rerender)
            await rerender();
        });
      }
    }
  }
}
async function renderRatchetHeatmap(source, el, plugin) {
  var _a;
  const params = parseBlockParams(source);
  const trackerId = (_a = params.tracker) == null ? void 0 : _a.trim();
  if (!trackerId) {
    el.createSpan({ text: "ratchet-heatmap: specify tracker: <id>" });
    return;
  }
  const days = resolveHeatmapDays(params);
  const tracker = await plugin.getDataManager().getTracker(trackerId);
  if (!tracker) {
    el.createSpan({ text: `Tracker not found: ${trackerId}` });
    return;
  }
  const blockWrap = el.createDiv("ratchet-heatmap-block");
  const container = blockWrap.createDiv("ratchet-heatmap");
  await buildHeatmapInto(container, trackerId, days, plugin, {
    source,
    blockEl: el,
    rerender: async () => {
      el.empty();
      await renderRatchetHeatmap(source, el, plugin);
    }
  });
}
function registerRatchetSummary(plugin, callback) {
  plugin.registerMarkdownCodeBlockProcessor("ratchet-summary", callback);
}
async function renderRatchetSummary(source, el, plugin) {
  var _a;
  const params = parseBlockParams(source);
  const trackerId = (_a = params.tracker) == null ? void 0 : _a.trim();
  if (!trackerId) {
    el.createSpan({ text: "ratchet-summary: specify tracker: <id>" });
    return;
  }
  const days = resolveHeatmapDays(params);
  const dm = plugin.getDataManager();
  const tracker = await dm.getTracker(trackerId);
  if (!tracker) {
    el.createSpan({ text: `Tracker not found: ${trackerId}` });
    return;
  }
  const wrap = el.createDiv("ratchet-summary");
  wrap.style.setProperty("--ratchet-card-accent", tracker.color || "var(--background-modifier-border)");
  const left = wrap.createDiv("ratchet-summary-card");
  const right = wrap.createDiv("ratchet-summary-heatmap");
  renderTrackerCard(left, {
    tracker,
    dataManager: dm,
    onIncrement: async () => {
      el.empty();
      await renderRatchetSummary(source, el, plugin);
    }
  });
  const heatmapRoot = right.createDiv("ratchet-heatmap");
  await buildHeatmapInto(heatmapRoot, trackerId, days, plugin, {
    hideTitle: true,
    rerender: async () => {
      el.empty();
      await renderRatchetSummary(source, el, plugin);
    }
  });
}

// src/styles.ts
var RATCHET_STYLES = `
/* Counter block (card-style to match tracker cards) */
.ratchet-counter-wrap {
	width: fit-content;
	max-width: 360px;
	margin-top: 0.75em;
	margin-bottom: 0.75em;
	border: 1px solid var(--background-modifier-border);
	border-left-width: 4px;
	border-left-color: var(--ratchet-card-accent, var(--background-modifier-border));
	border-radius: 6px;
	padding: 0.75em;
	background: var(--background-secondary);
}
.ratchet-counter-top { display: flex; align-items: center; gap: 0.35em; margin-bottom: 0.25em; }
.ratchet-counter-icon { font-size: 1.1em; }
.ratchet-counter-name { font-weight: 600; }
.ratchet-counter-value { font-size: 1.5em; font-weight: 600; margin-bottom: 0.35em; }
.ratchet-counter-unit { font-weight: normal; font-size: 0.85em; opacity: 0.9; }
.ratchet-counter-buttons { display: flex; flex-wrap: wrap; gap: 0.25em; }
.ratchet-counter-buttons button {
	padding: 0.2em 0.5em;
	font-size: 0.9em;
	cursor: pointer;
	border-radius: 4px;
	border: 1px solid var(--background-modifier-border);
	background: var(--background-secondary);
	color: var(--text-normal);
}
.ratchet-counter-buttons button:hover { background: var(--background-modifier-hover); }
.ratchet-counter-goal { font-size: 0.9em; color: var(--text-muted); }
.ratchet-counter-goal-met { color: var(--interactive-success); }
.ratchet-counter-error { color: var(--text-error); font-size: 0.9em; }

/* Multiple counter cards in one block */
.ratchet-counters {
	display: flex;
	flex-wrap: wrap;
	gap: 0.75em;
	margin-top: 0.75em;
	margin-bottom: 0.75em;
}
.ratchet-counters .ratchet-counter-wrap {
	margin: 0;
}

/* Tracker card (dashboard + summary) */
.ratchet-card {
	border: 1px solid var(--background-modifier-border);
	border-left-width: 4px;
	border-left-color: var(--ratchet-card-accent, var(--background-modifier-border));
	border-radius: 6px;
	padding: 0.75em;
	background: var(--background-secondary);
}
.ratchet-card-header {
	display: flex;
	align-items: center;
	gap: 0.35em;
	margin-bottom: 0.35em;
}
.ratchet-card-header-clickable { cursor: pointer; }
.ratchet-card-icon { font-size: 1.1em; }
.ratchet-card-name { font-weight: 600; }
.ratchet-card-value { font-size: 1.5em; font-weight: 600; margin-bottom: 0.35em; font-variant-numeric: tabular-nums; }
.ratchet-card-unit { font-weight: normal; font-size: 0.85em; opacity: 0.9; }
.ratchet-card-buttons {
	display: flex;
	flex-wrap: wrap;
	gap: 0.25em;
	margin-bottom: 0.35em;
}
.ratchet-card-buttons button {
	padding: 0.25em 0.5em;
	font-size: 0.9em;
	cursor: pointer;
	border-radius: 4px;
	border: 1px solid var(--background-modifier-border);
	background: var(--background-primary);
	color: var(--text-normal);
}
.ratchet-card-buttons button:hover { background: var(--background-modifier-hover); }
.ratchet-card-progress-wrap { margin-bottom: 0.35em; }
.ratchet-card-progress {
	height: 6px;
	border-radius: 3px;
	background: var(--background-modifier-border);
	overflow: hidden;
}
.ratchet-card-progress-fill {
	height: 100%;
	border-radius: 3px;
	transition: width 0.2s ease;
}
.ratchet-card-goal { font-size: 0.9em; color: var(--text-muted); }
.ratchet-card-goal-met { color: var(--interactive-success); }

/* Standalone heatmap block: spacing when stacked with other widgets */
.ratchet-heatmap-block {
	margin-top: 0.75em;
	margin-bottom: 0.75em;
}

/* Heatmap - GitHub / Heatmap Plugin style */
.ratchet-heatmap {
	--heatmap-cell-size: 11px;
	--heatmap-gap: 3px;
	--heatmap-cols: 53;
	font-family: var(--font-interface), sans-serif;
	padding: 0.5em 0;
}
.ratchet-heatmap-title {
	font-size: 1em;
	font-weight: 600;
	margin-bottom: 8px;
	text-align: center;
	color: var(--text-normal);
}
.ratchet-heatmap-body {
	display: grid;
	grid-template-columns: auto 1fr;
	grid-template-rows: auto 1fr;
	gap: 0 8px;
	align-items: start;
}
.ratchet-heatmap-months {
	grid-column: 2;
	grid-row: 1;
	display: grid;
	grid-template-columns: repeat(var(--heatmap-cols), var(--heatmap-cell-size));
	gap: var(--heatmap-gap);
	margin-bottom: 2px;
	height: calc(var(--heatmap-cell-size) + 2px);
}
.ratchet-heatmap-month {
	font-size: 9px;
	color: var(--text-muted);
	line-height: var(--heatmap-cell-size);
}
.ratchet-heatmap-day-labels {
	grid-column: 1;
	grid-row: 2;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	height: calc(7 * (var(--heatmap-cell-size) + var(--heatmap-gap)) - var(--heatmap-gap));
}
.ratchet-heatmap-day-label {
	font-size: 9px;
	color: var(--text-muted);
	height: var(--heatmap-cell-size);
	line-height: var(--heatmap-cell-size);
}
.ratchet-heatmap-grid {
	grid-column: 2;
	grid-row: 2;
	display: flex;
	flex-direction: column;
	gap: var(--heatmap-gap);
}
.ratchet-heatmap-row {
	display: grid;
	grid-template-columns: repeat(var(--heatmap-cols), var(--heatmap-cell-size));
	gap: var(--heatmap-gap);
}
.ratchet-heatmap-cell {
	width: var(--heatmap-cell-size);
	height: var(--heatmap-cell-size);
	border-radius: 2px;
	box-sizing: border-box;
}
.ratchet-heatmap-cell-today {
	outline: 2px solid var(--text-normal);
	outline-offset: -2px;
}
.ratchet-heatmap-cell-empty {
	background-color: var(--background-secondary-alt);
}
.ratchet-heatmap-cell-clickable {
	cursor: pointer;
}
.ratchet-heatmap-cell-clickable:hover {
	filter: brightness(1.1);
}

/* ratchet-summary: card with info left, heatmap right, same background (width like settings cards) */
.ratchet-summary {
	--ratchet-card-accent: var(--background-modifier-border);
	display: flex;
	align-items: flex-start;
	gap: 1rem;
	width: fit-content;
	max-width: 720px;
	margin-top: 0.75em;
	margin-bottom: 0.75em;
	border: 1px solid var(--background-modifier-border);
	border-left-width: 4px;
	border-left-color: var(--ratchet-card-accent);
	border-radius: 6px;
	padding: 0.75em;
	background: var(--background-secondary);
	box-sizing: border-box;
}
.ratchet-summary .ratchet-card {
	border: none;
	background: transparent;
	padding: 0;
}
.ratchet-summary-card {
	flex: 0 0 auto;
	min-width: 180px;
}
.ratchet-summary-heatmap {
	flex: 1 1 auto;
	min-width: 0;
}
.ratchet-summary-heatmap .ratchet-heatmap {
	padding: 0;
}

/* Edit tracker: past entries grid */
.ratchet-past-entries-section {
	margin-top: 1em;
	border-top: 1px solid var(--background-modifier-border);
	padding-top: 1em;
}
.ratchet-past-entries-section h3 {
	margin: 0 0 0.5em 0;
	font-size: 1em;
}
.ratchet-entries-range-setting { margin-bottom: 0.5em; }
.ratchet-entries-table-wrap {
	max-height: 280px;
	overflow-y: auto;
	margin-top: 0.5em;
}
.ratchet-entries-empty {
	color: var(--text-muted);
	font-size: 0.9em;
}
.ratchet-entries-table {
	width: 100%;
	border-collapse: collapse;
	font-size: 0.9em;
}
.ratchet-entries-table th,
.ratchet-entries-table td {
	text-align: left;
	padding: 0.35em 0.5em;
	border-bottom: 1px solid var(--background-modifier-border);
}
.ratchet-entries-table th { color: var(--text-muted); font-weight: 500; }
.ratchet-entries-date { white-space: nowrap; }
.ratchet-entries-value { font-variant-numeric: tabular-nums; }
.ratchet-entries-count-input {
	width: 4em;
	padding: 0.25em 0.4em;
	border-radius: 4px;
	border: 1px solid var(--background-modifier-border);
	background: var(--background-primary);
	color: var(--text-normal);
	font-variant-numeric: tabular-nums;
}
.ratchet-entries-count-input:focus {
	outline: none;
	border-color: var(--interactive-accent);
}
`;

// main.ts
var RatchetPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.dataManager = null;
    /** Which tracker is selected for editing in the main view: null, "new", or tracker id. */
    this.ratchetViewState = { selectedId: null };
  }
  async onload() {
    const styleEl = document.createElement("style");
    styleEl.textContent = RATCHET_STYLES;
    styleEl.setAttribute("data-ratchet-styles", "true");
    document.head.appendChild(styleEl);
    this.register(() => styleEl.remove());
    await this.loadSettings();
    this.refreshDataManager();
    this.registerView(
      VIEW_TYPE_RATCHET_MAIN,
      (leaf) => new RatchetMainView(leaf, this)
    );
    this.addRibbonIcon("tally-5", "Ratchet", () => {
      this.activateRatchetView();
    });
    this.addCommand({
      id: "open-dashboard",
      name: "Open Ratchet",
      callback: () => this.activateRatchetView()
    });
    this.addCommand({
      id: "create-tracker",
      name: "Create new tracker",
      callback: () => {
        this.ratchetViewState.selectedId = "new";
        this.activateRatchetView();
      }
    });
    this.addSettingTab(new RatchetSettingTab(this.app, this));
    registerRatchetCounter(this, (source, el) => {
      renderRatchetCounter(source, el, this).catch(() => {
      });
    });
    registerRatchetHeatmap(this, (source, el) => {
      renderRatchetHeatmap(source, el, this).catch(() => {
      });
    });
    registerRatchetSummary(this, (source, el) => {
      renderRatchetSummary(source, el, this).catch(() => {
      });
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_RATCHET_MAIN);
  }
  activateRatchetView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_RATCHET_MAIN)[0];
    if (!leaf) {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        leaf.setViewState({ type: VIEW_TYPE_RATCHET_MAIN, active: true });
      }
    }
    if (leaf)
      workspace.revealLeaf(leaf);
  }
  getDataManager() {
    if (!this.dataManager) {
      this.refreshDataManager();
    }
    return this.dataManager;
  }
  refreshDataManager() {
    this.dataManager = new DataManager(
      this.app.vault,
      this.settings.dataFolder,
      this.settings.firstDayOfWeek
    );
  }
  async loadSettings() {
    this.settings = { ...DEFAULT_SETTINGS, ...await this.loadData() };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
